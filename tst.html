<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - equirectangular panorama</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
    body {
        background-color: #000000;
        margin: 0px;
        overflow: hidden;
    }
    
    #info {
        position: absolute;
        top: 0px;
        width: 100%;
        color: #ffffff;
        padding: 5px;
        font-family: Monospace;
        font-size: 13px;
        font-weight: bold;
        text-align: center;
    }
    
    a {
        color: #ffffff;
    }
    </style>
</head>

<body>
    <div id="container"></div>
    <div id="info">
        <a href="http://threejs.org" target="_blank">three.js webgl</a> - equirectangular panorama demo. photo by <a href="http://www.flickr.com/photos/jonragnarsson/2294472375/" target="_blank">JÃ³n Ragnarsson</a>.
        <br /> drag equirectangular texture into the page.
    </div>
    <script src="./build/three.js"></script>
    <script>
    var camera, scene, renderer;

    var ouput = false;

    var width, height;
    var isUserInteracting = false,
        onMouseDownMouseX = 0,
        onMouseDownMouseY = 0,
        lon = 0,
        onMouseDownLon = 0,
        lat = 0,
        onMouseDownLat = 0,
        phi = 0,
        theta = 0;

    // Movement speed
	var PSV_LONG_OFFSET =  Math.PI / 360.0;
	var PSV_LAT_OFFSET = Math.PI / 180.0;

	var PSV_KEYBOARD_LONG_OFFSET = Math.PI / 60.0;
	var PSV_KEYBOARD_LAT_OFFSET =  Math.PI / 120.0;

	// Minimum and maximum fields of view in degrees
	var PSV_FOV_MIN =  30;
	var PSV_FOV_MAX =  90;

	// Minimum tilt up / down angles
	var PSV_TILT_UP_MAX =  Math.PI / 2.0;
	var PSV_TILT_DOWN_MAX = -Math.PI / 2.0;

	// Minimum and maximum visible longitudes
	var min_long =  0;
	var	max_long = 2 * Math.PI;

	var PSV_MIN_LONGITUDE, PSV_MAX_LONGITUDE;
	if (min_long < max_long) {
		PSV_MIN_LONGITUDE = min_long;
		PSV_MAX_LONGITUDE = max_long;
	}

	else {
		PSV_MIN_LONGITUDE = max_long;
		PSV_MAX_LONGITUDE = min_long;
	}


    init();
    animate();

    function init() {

        var container, mesh;

        container = document.getElementById('container');

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 500);
        camera.target = new THREE.Vector3(0, 0, 0);

        scene = new THREE.Scene();

        var geometry = new THREE.SphereGeometry(500, 60, 40);
        geometry.scale(-1, 1, 1);

        var texloader = new THREE.TextureLoader();
        var tex = texloader.load("1.jpg");

        var material = new THREE.MeshBasicMaterial({
            map: tex
        });

        material.side = THREE.DoubleSided;
        mesh = new THREE.Mesh(geometry, material);

        scene.add(mesh);

      


        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        document.addEventListener('mousedown', onDocumentMouseDown, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false);

        document.addEventListener('keydown', onDocumentKeyDown, false);
        document.addEventListener('wheel', onDocumentMouseWheel, false);

        //

        document.addEventListener('dragover', function(event) {

            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';

        }, false);

        document.addEventListener('dragenter', function(event) {

            document.body.style.opacity = 0.5;

        }, false);

        document.addEventListener('dragleave', function(event) {

            document.body.style.opacity = 1;

        }, false);

        document.addEventListener('drop', function(event) {

            event.preventDefault();

            var reader = new FileReader();
            reader.addEventListener('load', function(event) {

                material.map.image.src = event.target.result;
                material.map.needsUpdate = true;

            }, false);
            reader.readAsDataURL(event.dataTransfer.files[0]);

            document.body.style.opacity = 1;

        }, false);

        //

        window.addEventListener('resize', onWindowResize, false);

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    function onDocumentMouseDown(event) {

        event.preventDefault();

        isUserInteracting = true;

        onPointerDownPointerX = event.clientX;
        onPointerDownPointerY = event.clientY;

        onPointerDownLon = lon;
        onPointerDownLat = lat;

        if (ouput == true) {
            var vector = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5);
            //projector.unprojectVector(vector, camera);
            var raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(vector, camera);
            var intersects = raycaster.intersectObjects(scene.children, true);

            console.log(window.innerWidth, window.innerHeight);
            if (intersects.length > 0) {

                point = intersects[0].point.clone();
                //console.log(raycasterPoint.y);
                // console.info('{ ' + -point.x.toFixed(2) + ', ' + point.y.toFixed(2) + ', ' + point.z.toFixed(2) + ' }');
            }

            getEqcoordinate(point)
        }


    }

    function getEqcoordinate(point) {
        var phi, theta;
        var R = 500;
        width = scene.children[0].material.map.image.width;
        height = scene.children[0].material.map.image.height;

        var p_lat = Math.asin(point.y / R);
        var p_long = Math.asin(point.x / (R * Math.cos(p_lat)));

        var t0 = stayBetween(lat,  PSV_TILT_DOWN_MAX, PSV_TILT_UP_MAX);
        var t1 = stayBetween(lon,   PSV_MIN_LONGITUDE, PSV_MAX_LONGITUDE);

        // console.log(camera.target)
        // console.log(point)
        //
        console.log(lat / Math.PI * 180, lon / Math.PI * 180)
        console.log(p_lat / Math.PI * 180, p_long / Math.PI *180)
       

    }

    function onDocumentMouseMove(event) {

        if (isUserInteracting === true) {

            lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
            lat = (event.clientY - onPointerDownPointerY) * 0.1 + onPointerDownLat;

            lon = getAngleMeasure(lon, true);

            lat = stayBetween(lat, PSV_TILT_DOWN_MAX, PSV_TILT_UP_MAX);

        }

    //     if (!whole_circle)
				//lon = stayBetween(long, PSV_MIN_LONGITUDE, PSV_MAX_LONGITUDE);

    }

	function getAngleMeasure(angle, is_2pi_allowed) {
		is_2pi_allowed = (is_2pi_allowed !== undefined) ? !!is_2pi_allowed : false;
		return (is_2pi_allowed && angle == 2 * Math.PI) ? 2 * Math.PI :  angle - Math.floor(angle / (2.0 * Math.PI)) * 2.0 * Math.PI;
	}

	function stayBetween(x, min, max) {
		return Math.max(min, Math.min(max, x));
	};

    function onDocumentMouseUp(event) {

        isUserInteracting = false;

    }

    function onDocumentMouseWheel(event) {

        camera.fov += event.deltaY * 0.05;
        camera.updateProjectionMatrix();

    }

    function onDocumentKeyDown(event) {

        if (retrieveKey(event) == 'ArrowAlt') {
            ouput = true;
        }

    }

    function retrieveKey(evt) {
        // The Holy Grail
        if (evt.key) {
            var key = (/^Arrow/.test(evt.key)) ? evt.key : 'Arrow' + evt.key;
            return key;
        }

        // Deprecated but still used
        if (evt.keyCode || evt.which) {
            var key_code = (evt.keyCode) ? evt.keyCode : evt.which;

            var keycodes_map = {
                38: 'ArrowUp',
                39: 'ArrowRight',
                40: 'ArrowDown',
                37: 'ArrowLeft',
                18: 'alt'
            };

            if (keycodes_map[key_code] !== undefined)
                return keycodes_map[key_code];
        }

        // :/
        return '';
    };

    function animate() {

        requestAnimationFrame(animate);
        update();

    }

    function update() {

        // if (isUserInteracting === false) {

        //     lon += 0.1;

        // }

        lat = Math.max(-85, Math.min(85, lat));
        phi = THREE.Math.degToRad(90 - lat);
        theta = THREE.Math.degToRad(lon);

        camera.target.x = 500 * Math.sin(phi) * Math.cos(theta);
        camera.target.y = 500 * Math.cos(phi);
        camera.target.z = 500 * Math.sin(phi) * Math.sin(theta);

        camera.lookAt(camera.target);

        /*
        // distortion
        camera.position.copy( camera.target ).negate();
        */

        renderer.render(scene, camera);

    }
    </script>
</body>

</html>
